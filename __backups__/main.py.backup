# === END SYNOPSIS HEADER ===
# === END SYNOPSIS HEADER ===
# === END SYNOPSIS HEADER ===
# === END SYNOPSIS HEADER ===
# === END SYNOPSIS HEADER ===
#!/usr/bin/env python3
"""
Code Synopsis Annotator - Main Entry Point

This is the main entry point for the modularized code synopsis annotator.
It provides both command-line and interactive modes for analyzing Python files.
"""

import sys
import os
from typing import Optional

# Add the parent directory to the path so we can import the module
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from code_synopsis_annotator.file_io import FileIOHandler
from code_synopsis_annotator.core_analyzer import CodeAnalyzer
from code_synopsis_annotator.behavioral_analysis import BehavioralAnalyzer
from code_synopsis_annotator.synopsis_renderer import SynopsisRenderer


def main():
    """
    Main entry point for the code synopsis annotator.
    
    Supports both command-line and interactive modes:
    - Command line: python main.py <filepath>
    - Interactive: python main.py (opens file dialog)
    """
    if len(sys.argv) > 1:
        # Command line mode
        filepath = sys.argv[1]
        print(f"Code Synopsis Annotator v2.0.0")
        print(f"Analyzing file: {filepath}")
        
        if not os.path.exists(filepath):
            print(f"Error: File '{filepath}' does not exist.")
            sys.exit(1)
        
        if not filepath.endswith(('.py', '.pyw')):
            print(f"Warning: File '{filepath}' may not be a Python file.")
        
        handler = FileIOHandler()
        success = handler.analyze_file(filepath)
        
        if success:
            print("Analysis completed successfully!")
        else:
            print("Analysis failed!")
            sys.exit(1)
    else:
        # Interactive mode
        print("Code Synopsis Annotator v2.0.0")
        print("Interactive mode - file dialog will open...")
        
        handler = FileIOHandler()
        handler.select_file_and_analyze()


def analyze_file(filepath: str, include_machine_block: bool = True) -> Optional[dict]:
    """
    Analyze a single file and return results.
    
    Args:
        filepath: Path to the Python file to analyze
        include_machine_block: Whether to include machine-readable data block
        
    Returns:
        Dictionary with analysis results, or None if analysis failed
    """
    try:
        # Create shared state for this analysis
        from .analyzer_state import new_state
        state = new_state()
        
        analyzer = CodeAnalyzer(filepath, state, include_machine_block=include_machine_block)
        analyzer.analyze()
        
        behavioral_analyzer = BehavioralAnalyzer(analyzer, state)
        renderer = SynopsisRenderer(analyzer, behavioral_analyzer, state)
        
        # Get analysis summary
        handler = FileIOHandler()
        summary = handler.get_analysis_summary(analyzer)
        
        return {
            'analyzer': analyzer,
            'behavioral_analyzer': behavioral_analyzer,
            'renderer': renderer,
            'summary': summary
        }
    except Exception as e:
        print(f"Error analyzing file {filepath}: {e}")
        return None


def batch_analyze(files: list, include_machine_block: bool = True) -> dict:
    """
    Analyze multiple files in batch.
    
    Args:
        files: List of file paths to analyze
        include_machine_block: Whether to include machine-readable data block
        
    Returns:
        Dictionary with results for each file
    """
    results = {}
    
    for filepath in files:
        print(f"Processing: {filepath}")
        result = analyze_file(filepath, include_machine_block)
        results[filepath] = result
    
    return results


if __name__ == "__main__":
    main()
