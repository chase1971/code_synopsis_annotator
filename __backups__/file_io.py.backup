# === END SYNOPSIS HEADER ===
# === END SYNOPSIS HEADER ===
# === END SYNOPSIS HEADER ===
# === END SYNOPSIS HEADER ===
"""
File I/O Handler - File operations and UI interactions.

This module handles file operations, UI interactions, and the main
entry point for the code synopsis annotator application.
"""

import os
import sys
import time
import tkinter as tk
from tkinter import filedialog, messagebox
from typing import Optional

from .core_analyzer import CodeAnalyzer
from .behavioral_analysis import BehavioralAnalyzer
from .synopsis_renderer import SynopsisRenderer


class FileIOHandler:
    """
    Handles file I/O operations and UI interactions.
    
    This class manages file operations, user interface interactions,
    and coordinates the analysis workflow.
    """
    
    def __init__(self):
        """Initialize the file I/O handler."""
        pass
    
    def create_annotated_file(self, analyzer: CodeAnalyzer, output_path: str):
        """Create an annotated file with synopsis header."""
        behavioral_analyzer = BehavioralAnalyzer(analyzer)
        renderer = SynopsisRenderer(analyzer, behavioral_analyzer)
        
        synopsis_header = renderer.generate_synopsis_header()
        annotated_code = synopsis_header + analyzer.code
        
        try:
            with open(output_path, 'w', encoding='utf-8') as f:
                f.write(annotated_code)
        except PermissionError as e:
            raise Exception(f"Permission error writing file: {e}")

    def select_file_and_analyze(self):
        """Select a file and run the complete analysis workflow."""
        try:
            root = tk.Tk()
            root.withdraw()
            root.lift()
            root.attributes('-topmost', True)
            root.focus_force()
            root.update()
            
            filepath = filedialog.askopenfilename(
                title="Select Python file to analyze",
                filetypes=[("Python files", "*.py *.pyw"), ("All files", "*.*")]
            )
            print(f"File selected: {filepath}")
            
            if filepath:
                time.sleep(0.3)
            else:
                print("No file selected - dialog was cancelled")
        except Exception as e:
            print(f"Error in file selection: {e}")
            import traceback
            traceback.print_exc()
            return

        if not filepath:
            messagebox.showinfo("Cancelled", "No file selected. Exiting.")
            return

        try:
            # Run analysis
            analyzer = CodeAnalyzer(filepath, include_machine_block=True)
            analyzer.analyze()
            
            # Create annotated file
            self.create_annotated_file(analyzer, filepath)
            
            # Show success message
            messagebox.showinfo(
                "Success!",
                (
                    f"Synopsis added to {os.path.basename(filepath)}!\n\n"
                    f"Functions: {len(analyzer.functions)}\n"
                    f"Classes: {len(analyzer.classes)}\n"
                    f"Globals: {len(analyzer.globals_found)}\n"
                    f"Threads: {len(analyzer.threads_found)}\n"
                )
            )
            
            # Open file in default editor
            try:
                if os.name == 'nt':
                    os.system(f'notepad "{filepath}"')
                elif os.name == 'posix':
                    os.system(f'open "{filepath}"' if sys.platform == 'darwin' else f'xdg-open "{filepath}"')
            except Exception:
                pass
            
            print("\n" + "="*50)
            print("ANALYSIS COMPLETE!")
            print("="*50)
            print(f"File processed: {os.path.basename(filepath)}")
            print("The synopsis has been added to your file.")
            
            try:
                input("Press Enter to exit...")
            except Exception:
                pass
                
        except Exception as e:
            messagebox.showerror("Error", f"An error occurred:\n\n{str(e)}")

    def analyze_file(self, filepath: str) -> bool:
        """
        Analyze a specific file and create annotated version.
        
        Args:
            filepath: Path to the Python file to analyze
            
        Returns:
            True if analysis was successful, False otherwise
        """
        try:
            print(f"Analyzing file: {filepath}")
            
            # Run analysis
            analyzer = CodeAnalyzer(filepath, include_machine_block=True)
            analyzer.analyze()
            
            # Create annotated file
            self.create_annotated_file(analyzer, filepath)
            
            print("Analysis complete!")
            return True
            
        except Exception as e:
            print(f"Error analyzing file {filepath}: {e}")
            return False

    def batch_analyze_files(self, filepaths: list) -> dict:
        """
        Analyze multiple files in batch.
        
        Args:
            filepaths: List of file paths to analyze
            
        Returns:
            Dictionary with results for each file
        """
        results = {}
        
        for filepath in filepaths:
            print(f"Processing: {filepath}")
            results[filepath] = self.analyze_file(filepath)
        
        return results

    def get_analysis_summary(self, analyzer: CodeAnalyzer) -> dict:
        """
        Get a summary of analysis results.
        
        Args:
            analyzer: The CodeAnalyzer instance
            
        Returns:
            Dictionary with analysis summary
        """
        return {
            'filename': analyzer.filename,
            'functions': len(analyzer.functions),
            'classes': len(analyzer.classes),
            'globals': len(analyzer.globals_found),
            'threads': len(analyzer.threads_found),
            'imports_external': len(analyzer.imports_external),
            'imports_local': len(analyzer.imports_local),
            'io_reads': len(analyzer.io_reads),
            'io_writes': len(analyzer.io_writes),
            'call_roots': len(analyzer.call_roots),
            'state_vars': len(analyzer.state_vars),
            'ui_after_users': len(analyzer.ui_after_users)
        }


def main():
    """Main entry point for the application."""
    if len(sys.argv) > 1:
        # Command line mode
        filepath = sys.argv[1]
        print(f"Using file from command line: {filepath}")
        
        handler = FileIOHandler()
        success = handler.analyze_file(filepath)
        
        if not success:
            sys.exit(1)
    else:
        # Interactive mode
        handler = FileIOHandler()
        handler.select_file_and_analyze()


if __name__ == "__main__":
    main()
