#!/usr/bin/env python3
# =============================================================================
# CORE ANALYZER (safe, non-blocking) — AST-based static analyzer
# - Preserves original public surface used by the rest of your pipeline
# - Adds FUNCTION_SIGNATURES with heavy-guarded unparse to avoid stalls
# =============================================================================

from __future__ import annotations
import ast
import os
import re
from collections import defaultdict
from typing import Dict, List, Set, Tuple, Any, Optional


HEADER_END_MARKS = (
    "# === END SYNOPSIS HEADER ===",
    "# ════════════════════",  # fallback if older headers
)


class CodeAnalyzer:
    # -------------------------------------------------------------------------
    # Construction / fields expected by other modules
    # -------------------------------------------------------------------------
    def __init__(self, filepath: str, include_machine_block: bool = False):
        self.filepath: str = os.path.abspath(filepath)
        self.filename: str = os.path.basename(self.filepath)

        # Raw content / AST
        self.source_code: str = ""
        self.tree: Optional[ast.AST] = None

        # Core artifacts consumed by BehavioralAnalyzer / SynopsisRenderer
        self.functions: Dict[str, Dict[str, Any]] = {}      # name -> info dict
        self.classes: Dict[str, Dict[str, Any]] = {}        # name -> info dict
        self.call_graph: Dict[str, Set[str]] = defaultdict(set)  # caller -> callees

        # Globals / IO / imports / threading / hotkeys
        self.globals: Set[str] = set()
        self.imports_external: Set[str] = set()
        self.imports_local: Set[str] = set()
        self.thread_targets: Set[str] = set()
        self.file_reads: List[Tuple[str, str]] = []   # [(path, mode)]
        self.file_writes: List[Tuple[str, str]] = []

        # State machine-ish placeholders used downstream
        self.state_vars: Dict[str, Dict[str, Any]] = defaultdict(lambda: {"values": set()})
        self.state_transitions: Dict[str, Set[str]] = defaultdict(set)
        self.hotkeys: List[Tuple[str, str]] = []  # [(func, hotkey)]
        self.hotkeys_pretty: List[str] = []

        # NEW: function signatures (guarded)
        self.function_signatures: Dict[str, Dict[str, Any]] = {}

        # Header strip markers cache
        self._found_end_marker: bool = False
        self._synopsis_end_line: int = -1

    # -------------------------------------------------------------------------
    # File handling
    # -------------------------------------------------------------------------
    def read_file(self) -> str:
        try:
            with open(self.filepath, "r", encoding="utf-8") as f:
                self.source_code = f.read()
        except Exception as e:
            self.source_code = ""
            raise
        return self.source_code

    def strip_existing_synopsis(self, code: str) -> Tuple[str, Dict[str, Any]]:
        """
        Remove prior injected synopsis header so we parse only the code body.
        Returns (stripped_code, info)
        """
        lines = code.splitlines()
        end_idx = -1
        for i, line in enumerate(lines[:400]):  # scan only early header area
            if any(line.strip().startswith(mark) for mark in HEADER_END_MARKS):
                end_idx = i
                break

        self._found_end_marker = end_idx != -1
        self._synopsis_end_line = end_idx

        if end_idx == -1:
            return code, {"removed": False, "lines": 0}

        # keep the line after the end marker
        body = "\n".join(lines[end_idx + 1 :])
        return body, {"removed": True, "lines": end_idx + 1}

    def parse_code(self) -> ast.AST:
        if not self.source_code:
            self.read_file()
        # Strip header if present
        code, info = self.strip_existing_synopsis(self.source_code)
        try:
            self.tree = ast.parse(code)
        except Exception:
            # If parsing stripped body fails, try raw as a fallback
            self.tree = ast.parse(self.source_code)
        return self.tree

    # -------------------------------------------------------------------------
    # Main pipeline (order chosen to match the expectations in your other modules)
    # -------------------------------------------------------------------------
    def analyze(self) -> None:
        self.parse_code()

        self.find_globals()
        self.analyze_classes()
        self.analyze_functions()
        self.find_imports()
        self.find_threading()
        self.find_hotkeys_and_ui_binds()
        self.find_file_io()
        self.build_call_graph()
        self.detect_state_machines()
        self.detect_ui_after_usage()
        self.summarize_initialization_sequence()

        # Optional extractions that your other modules sometimes call
        extra_calls = self.extract_call_graph(self.tree)
        for caller, callees in extra_calls.items():
            self.call_graph[caller].update(callees)

        extra_transitions = self.extract_state_transitions(self.tree)
        self.state_transitions = extra_transitions
        for var, vals in extra_transitions.items():
            self.state_vars[var]["values"].update(vals)

        self.hotkeys_pretty = self.extract_hotkey_bindings()

        # NEW: safe function-signature capture (guarded; non-blocking)
        self.extract_function_signatures()

    # -------------------------------------------------------------------------
    # Globals
    # -------------------------------------------------------------------------
    def find_globals(self) -> None:
        if not self.tree:
            return
        for node in ast.walk(self.tree):
            if isinstance(node, ast.Assign):
                for t in node.targets:
                    if isinstance(t, ast.Name):
                        self.globals.add(t.id)

    # -------------------------------------------------------------------------
    # Classes
    # -------------------------------------------------------------------------
    def analyze_classes(self) -> None:
        if not self.tree:
            return
        for node in self.tree.body:
            if isinstance(node, ast.ClassDef):
                attrs = set()
                methods = []
                # Collect attributes from __init__
                for sub in node.body:
                    if isinstance(sub, ast.FunctionDef):
                        methods.append(sub.name)
                        if sub.name == "__init__":
                            for stmt in ast.walk(sub):
                                if isinstance(stmt, ast.Assign):
                                    for t in stmt.targets:
                                        if isinstance(t, ast.Attribute) and isinstance(t.value, ast.Name) and t.value.id == "self":
                                            attrs.add(t.attr)
                self.classes[node.name] = {
                    "attributes": sorted(attrs),
                    "methods": sorted(methods),
                    "lineno": getattr(node, "lineno", None),
                }

    # -------------------------------------------------------------------------
    # Functions
    # -------------------------------------------------------------------------
    def analyze_functions(self) -> None:
        if not self.tree:
            return
        for node in ast.walk(self.tree):
            if isinstance(node, ast.FunctionDef):
                reads: Set[str] = set()
                writes: Set[str] = set()
                # Simple RW heuristic
                for sub in ast.walk(node):
                    if isinstance(sub, ast.Name):
                        if isinstance(sub.ctx, ast.Load):
                            reads.add(sub.id)
                        elif isinstance(sub.ctx, ast.Store):
                            writes.add(sub.id)
                self.functions[node.name] = {
                    "lineno": getattr(node, "lineno", None),
                    "reads": sorted(reads),
                    "writes": sorted(writes),
                }

    # -------------------------------------------------------------------------
    # Imports
    # -------------------------------------------------------------------------
    def _is_local_module(self, name: str) -> bool:
        # Treat dotted names' head as module
        head = name.split(".")[0]
        # crude heuristic: if a sibling .py exists, call it local
        folder = os.path.dirname(self.filepath)
        return os.path.exists(os.path.join(folder, f"{head}.py"))

    def find_imports(self) -> None:
        if not self.tree:
            return
        for node in ast.walk(self.tree):
            if isinstance(node, ast.Import):
                for alias in node.names:
                    (self.imports_local if self._is_local_module(alias.name) else self.imports_external).add(alias.name)
            elif isinstance(node, ast.ImportFrom):
                mod = node.module or ""
                (self.imports_local if self._is_local_module(mod) else self.imports_external).add(mod)

    # -------------------------------------------------------------------------
    # Threading / UI-after
    # -------------------------------------------------------------------------
    def find_threading(self) -> None:
        if not self.tree:
            return
        for node in ast.walk(self.tree):
            if isinstance(node, ast.Call):
                # threading.Thread(target=foo)
                if isinstance(node.func, ast.Attribute) and node.func.attr == "Thread":
                    for kw in node.keywords or []:
                        if kw.arg == "target":
                            t = kw.value
                            if isinstance(t, ast.Name):
                                self.thread_targets.add(t.id)

    def detect_ui_after_usage(self) -> None:
        # Detect tk.after(...) usage (heuristic)
        if not self.tree:
            return
        for node in ast.walk(self.tree):
            if isinstance(node, ast.Call) and isinstance(node.func, ast.Attribute):
                if node.func.attr == "after":
                    # mark after usage by creating a pseudo state var
                    self.state_vars["_ui_after"]  # ensure existence

    # -------------------------------------------------------------------------
    # Hotkeys / binds
    # -------------------------------------------------------------------------
    _BIND_RE = re.compile(r"\.bind\(\s*['\"](?P<combo>[^'\"]+)['\"]\s*,\s*(?P<fn>[a-zA-Z_]\w*)")

    def find_hotkeys_and_ui_binds(self) -> None:
        if not self.source_code:
            return
        for m in self._BIND_RE.finditer(self.source_code):
            combo = m.group("combo")
            fn = m.group("fn")
            self.hotkeys.append((fn, combo))

    # Pretty list for headers
    def extract_hotkey_bindings(self) -> List[str]:
        return [f"{fn} -> {combo}" for fn, combo in sorted(self.hotkeys)]

    # -------------------------------------------------------------------------
    # File IO
    # -------------------------------------------------------------------------
    def _extract_open_args(self, call: ast.Call) -> Tuple[Optional[str], Optional[str]]:
        path = None
        mode = None
        if call.args:
            if isinstance(call.args[0], ast.Constant) and isinstance(call.args[0].value, str):
                path = call.args[0].value
        for kw in call.keywords or []:
            if kw.arg == "mode":
                if isinstance(kw.value, ast.Constant) and isinstance(kw.value.value, str):
                    mode = kw.value.value
        return path, mode

    def find_file_io(self) -> None:
        if not self.tree:
            return
        for node in ast.walk(self.tree):
            if isinstance(node, ast.Call) and isinstance(node.func, ast.Name) and node.func.id == "open":
                p, m = self._extract_open_args(node)
                if p is None:
                    continue
                if m and any(ch in m for ch in ("w", "a", "+")):
                    self.file_writes.append((p, m or "w"))
                else:
                    self.file_reads.append((p, m or "r"))

    # -------------------------------------------------------------------------
    # Call graph
    # -------------------------------------------------------------------------
    def _format_call_name(self, call: ast.Call) -> str:
        # foo(), mod.func(), obj.method()
        f = call.func
        if isinstance(f, ast.Name):
            return f.id
        if isinstance(f, ast.Attribute):
            # return "obj.method" or "mod.func"
            base = []
            cur = f
            while isinstance(cur, ast.Attribute):
                base.append(cur.attr)
                cur = cur.value
            if isinstance(cur, ast.Name):
                base.append(cur.id)
            return ".".join(reversed(base))
        return "<call>"

    def build_call_graph(self) -> None:
        if not self.tree:
            return
        enclosing = {}

        class Enclose(ast.NodeVisitor):
            def __init__(self, outer):
                self.stack = []
                self.outer = outer
            def visit_FunctionDef(self, n: ast.FunctionDef):
                self.stack.append(n.name)
                self.generic_visit(n)
                self.stack.pop()
            def visit_Call(self, n: ast.Call):
                if self.stack:
                    caller = self.stack[-1]
                    callee = self.outer._format_call_name(n)
                    if caller and callee:
                        self.outer.call_graph[caller].add(callee)
                self.generic_visit(n)

        Enclose(self).visit(self.tree)

    # -------------------------------------------------------------------------
    # State transitions (heuristic / placeholder)
    # -------------------------------------------------------------------------
    def extract_state_transitions(self, tree: ast.AST) -> Dict[str, Set[str]]:
        trans: Dict[str, Set[str]] = defaultdict(set)
        # very light heuristic: look for "state = 'X'"
        for node in ast.walk(tree):
            if isinstance(node, ast.Assign):
                for t in node.targets:
                    if isinstance(t, ast.Name) and isinstance(node.value, ast.Constant) and isinstance(node.value.value, str):
                        if t.id.endswith("_state") or t.id.endswith("State"):
                            trans[t.id].add(node.value.value)
        return trans

    def detect_state_machines(self) -> None:
        # placeholder hook — downstream tools just consume state_transitions/state_vars
        pass

    # -------------------------------------------------------------------------
    # Initialization summary (placeholder)
    # -------------------------------------------------------------------------
    def summarize_initialization_sequence(self) -> None:
        # kept minimal; renderer just expects the method to exist
        pass

    # -------------------------------------------------------------------------
    # Extra graph extraction (used by analyze() to augment call_graph)
    # -------------------------------------------------------------------------
    def extract_call_graph(self, tree: ast.AST) -> Dict[str, Set[str]]:
        # We already built call_graph, but return a shallow copy to match expectations
        return {k: set(v) for k, v in self.call_graph.items()}

    # -------------------------------------------------------------------------
    # NEW: SAFE, GUARDED SIGNATURE EXTRACTION
    # -------------------------------------------------------------------------
    def _safe_unparse(self, node: Optional[ast.AST]) -> str:
        """Safely stringify annotations/defaults/returns without heavy cost or recursion traps."""
        if node is None:
            return "None"

        # Short-circuit known heavy or deeply nested nodes
        if isinstance(node, (ast.Lambda, ast.ListComp, ast.SetComp, ast.DictComp, ast.GeneratorExp)):
            return "<complex>"
        if isinstance(node, (ast.List, ast.Set, ast.Dict, ast.Tuple)):
            return {
                ast.List:  "<list>",
                ast.Set:   "<set>",
                ast.Dict:  "<dict>",
                ast.Tuple: "<tuple>",
            }[type(node)]

        try:
            s = ast.unparse(node)  # Python 3.9+
            return s if len(s) <= 100 else "<long>"
        except Exception:
            return "<?>"

    def _render_arg(self, arg: ast.arg, default: Optional[ast.AST]) -> str:
        part = arg.arg
        if arg.annotation:
            part += f": {self._safe_unparse(arg.annotation)}"
        if default is not None:
            part += f" = {self._safe_unparse(default)}"
        return part

    def extract_function_signatures(self) -> None:
        """
        Collect flat one-liner signatures for:
          - top-level functions
          - class methods
        Guarded to avoid stalls from ast.unparse on huge/complex nodes.
        """
        self.function_signatures.clear()
        if not isinstance(self.tree, ast.Module):
            return

        def sig_from_def(fn: ast.FunctionDef) -> None:
            a = fn.args
            parts: List[str] = []

            # pos-only (Py3.8+)
            posonly = getattr(a, "posonlyargs", [])
            if posonly:
                parts.extend(self._render_arg(arg, None) for arg in posonly)
                parts.append("/")  # separator

            # normal args with defaults
            regular = list(a.args)
            defaults = [None] * (len(regular) - len(a.defaults)) + list(a.defaults)
            parts.extend(self._render_arg(arg, d) for arg, d in zip(regular, defaults))

            # *vararg or bare * for kw-only
            if a.vararg:
                va = f"*{a.vararg.arg}"
                if a.vararg.annotation:
                    va += f": {self._safe_unparse(a.vararg.annotation)}"
                parts.append(va)
            elif a.kwonlyargs:
                parts.append("*")

            # kw-only
            for kw_arg, d in zip(a.kwonlyargs, a.kw_defaults):
                parts.append(self._render_arg(kw_arg, d))

            # **kwargs
            if a.kwarg:
                kaa = f"**{a.kwarg.arg}"
                if a.kwarg.annotation:
                    kaa += f": {self._safe_unparse(a.kwarg.annotation)}"
                parts.append(kaa)

            returns = self._safe_unparse(fn.returns)
            self.function_signatures[fn.name] = {
                "args": parts,
                "returns": returns,
            }

        # Top-level
        for node in self.tree.body:
            if isinstance(node, ast.FunctionDef):
                sig_from_def(node)
            elif isinstance(node, ast.ClassDef):
                for sub in node.body:
                    if isinstance(sub, ast.FunctionDef):
                        sig_from_def(sub)

    # -------------------------------------------------------------------------
    # Convenience pretty-printer (used by renderer if desired)
    # -------------------------------------------------------------------------
    def format_function_signatures(self) -> List[str]:
        out: List[str] = []
        for name, sig in self.function_signatures.items():
            out.append(f"{name}({', '.join(sig['args'])}) -> {sig['returns']}")
        return out
